# 시스템 아키텍처 설계서

## 1. 전체 아키텍처 개요

### 1.1 아키텍처 스타일
- **Layered Architecture (계층형 아키텍처)**
  - Presentation Layer (Controller)
  - Application Layer (Service)
  - Domain Layer (Entity, Repository)
  - Infrastructure Layer (외부 연동, 설정)

- **Clean Architecture 원칙 적용**
  - 도메인 중심 설계
  - 의존성 역전 원칙 (DIP)
  - 비즈니스 로직과 인프라 분리

### 1.2 시스템 구성도

```
┌─────────────────────────────────────────────────────────┐
│                     Client (Browser)                     │
└─────────────────────────────────────────────────────────┘
                            │
                            │ HTTPS
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   Spring Boot Application                │
│  ┌─────────────────────────────────────────────────────┐│
│  │           Presentation Layer                        ││
│  │  ┌────────────┐  ┌──────────────┐  ┌─────────────┐ ││
│  │  │ Controller │  │ ExceptionAdv │  │ Interceptor │ ││
│  │  └────────────┘  └──────────────┘  └─────────────┘ ││
│  └─────────────────────────────────────────────────────┘│
│                          │                               │
│  ┌─────────────────────────────────────────────────────┐│
│  │           Application Layer                         ││
│  │  ┌─────────┐  ┌────────┐  ┌──────────────────────┐ ││
│  │  │ Service │  │  Facade│  │  ApplicationService  │ ││
│  │  └─────────┘  └────────┘  └──────────────────────┘ ││
│  └─────────────────────────────────────────────────────┘│
│                          │                               │
│  ┌─────────────────────────────────────────────────────┐│
│  │           Domain Layer                              ││
│  │  ┌────────┐  ┌────────────┐  ┌──────────────────┐  ││
│  │  │ Entity │  │ Repository │  │  DomainService   │  ││
│  │  └────────┘  └────────────┘  └──────────────────┘  ││
│  └─────────────────────────────────────────────────────┘│
│                          │                               │
│  ┌─────────────────────────────────────────────────────┐│
│  │         Infrastructure Layer                        ││
│  │  ┌────────┐  ┌─────────┐  ┌──────────────────────┐ ││
│  │  │ Config │  │ Security│  │  External Services   │ ││
│  │  └────────┘  └─────────┘  └──────────────────────┘ ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
            │                   │                │
            ▼                   ▼                ▼
    ┌────────────┐      ┌────────────┐   ┌────────────┐
    │  Database  │      │   Redis    │   │  Ehcache   │
    │  (MySQL)   │      │  (Cache)   │   │  (Local)   │
    └────────────┘      └────────────┘   └────────────┘
```

## 2. 기술 스택

### 2.1 Core Framework
- **Java 21 LTS**
  - Virtual Threads (Project Loom)
  - Record Types
  - Pattern Matching
  - Text Blocks, Switch Expressions

- **Spring Boot 3.3.x**
  - Spring Framework 6.1.x
  - Java 17 baseline, Java 21 최적화

### 2.2 Data Access
- **Spring Data JPA 3.3.x**
  - Hibernate 6.5.x
  - QueryDSL 5.1.x
  - Connection Pool: HikariCP

- **Database**
  - Primary: MySQL 8.0 또는 PostgreSQL 16
  - 개발: H2 In-Memory Database

### 2.3 Security
- **Spring Security 6.3.x**
  - JWT (jjwt 0.12.x)
  - BCrypt Password Encoder
  - Method Security

### 2.4 Caching
- **Redis 7.x**
  - Spring Data Redis
  - Lettuce Client
  - 분산 캐시, 세션 저장소

- **Ehcache 3.x**
  - JSR-107 (JCache) 구현
  - 로컬 캐시 (L1 Cache)

### 2.5 Validation & Mapping
- **Jakarta Bean Validation 3.0**
  - Hibernate Validator 8.0
  - Custom Validators

- **MapStruct 1.5.x**
  - Compile-time DTO Mapping
  - Type-safe 매핑

### 2.6 Monitoring & Observability
- **Spring Boot Actuator**
  - Health Check
  - Metrics (Micrometer)
  - Prometheus Integration

- **Logging**
  - SLF4J + Logback
  - JSON Logging (Logstash Encoder)

### 2.7 Testing
- **JUnit 5 (Jupiter)**
- **Mockito**
- **AssertJ**
- **Spring Boot Test**
- **Testcontainers** (통합 테스트)
- **JMH** (벤치마킹)

### 2.8 Documentation
- **Spring REST Docs**
  - AsciiDoc
  - API 문서 자동 생성

### 2.9 Build Tool
- **Gradle 8.x**
  - Kotlin DSL
  - Dependency Management

## 3. 패키지 구조

```
com.board
├── BoardApplication.java
│
├── domain                          # 도메인 계층
│   ├── user
│   │   ├── entity
│   │   │   ├── User.java
│   │   │   ├── Role.java
│   │   │   └── UserStatus.java
│   │   ├── repository
│   │   │   ├── UserRepository.java
│   │   │   └── UserRepositoryCustom.java
│   │   └── service
│   │       └── UserDomainService.java
│   │
│   ├── category
│   │   ├── entity
│   │   │   └── Category.java
│   │   └── repository
│   │       └── CategoryRepository.java
│   │
│   ├── post
│   │   ├── entity
│   │   │   ├── Post.java
│   │   │   ├── PostReaction.java
│   │   │   ├── PostView.java
│   │   │   └── ReactionType.java
│   │   ├── repository
│   │   │   ├── PostRepository.java
│   │   │   ├── PostReactionRepository.java
│   │   │   └── PostViewRepository.java
│   │   └── service
│   │       └── PostDomainService.java
│   │
│   ├── comment
│   │   ├── entity
│   │   │   ├── Comment.java
│   │   │   └── CommentReaction.java
│   │   ├── repository
│   │   │   ├── CommentRepository.java
│   │   │   └── CommentReactionRepository.java
│   │   └── service
│   │       └── CommentDomainService.java
│   │
│   └── common
│       ├── entity
│       │   └── BaseTimeEntity.java
│       └── exception
│           ├── DomainException.java
│           └── ErrorCode.java
│
├── application                     # 애플리케이션 계층
│   ├── auth
│   │   ├── AuthService.java
│   │   ├── JwtTokenProvider.java
│   │   └── dto
│   │       ├── LoginRequest.java
│   │       ├── SignupRequest.java
│   │       └── TokenResponse.java
│   │
│   ├── user
│   │   ├── UserService.java
│   │   └── dto
│   │       ├── UserResponse.java
│   │       └── UserUpdateRequest.java
│   │
│   ├── category
│   │   ├── CategoryService.java
│   │   └── dto
│   │       ├── CategoryRequest.java
│   │       └── CategoryResponse.java
│   │
│   ├── post
│   │   ├── PostService.java
│   │   ├── PostViewService.java
│   │   ├── PostReactionService.java
│   │   └── dto
│   │       ├── PostCreateRequest.java
│   │       ├── PostUpdateRequest.java
│   │       ├── PostResponse.java
│   │       ├── PostDetailResponse.java
│   │       └── PostSearchCondition.java
│   │
│   ├── comment
│   │   ├── CommentService.java
│   │   ├── CommentReactionService.java
│   │   └── dto
│   │       ├── CommentRequest.java
│   │       └── CommentResponse.java
│   │
│   └── common
│       ├── dto
│       │   ├── PageResponse.java
│       │   └── ApiResponse.java
│       └── mapper
│           ├── UserMapper.java
│           ├── PostMapper.java
│           └── CommentMapper.java
│
├── presentation                    # 프레젠테이션 계층
│   ├── auth
│   │   └── AuthController.java
│   ├── user
│   │   └── UserController.java
│   ├── category
│   │   └── CategoryController.java
│   ├── post
│   │   └── PostController.java
│   ├── comment
│   │   └── CommentController.java
│   │
│   └── common
│       ├── advice
│       │   └── GlobalExceptionHandler.java
│       ├── interceptor
│       │   └── LoggingInterceptor.java
│       └── resolver
│           └── CurrentUserArgumentResolver.java
│
├── infrastructure                  # 인프라 계층
│   ├── config
│   │   ├── JpaConfig.java
│   │   ├── RedisConfig.java
│   │   ├── CacheConfig.java
│   │   ├── AsyncConfig.java
│   │   ├── WebMvcConfig.java
│   │   └── QueryDslConfig.java
│   │
│   ├── security
│   │   ├── SecurityConfig.java
│   │   ├── JwtAuthenticationFilter.java
│   │   ├── JwtAccessDeniedHandler.java
│   │   ├── JwtAuthenticationEntryPoint.java
│   │   └── CustomUserDetailsService.java
│   │
│   ├── cache
│   │   ├── CacheNames.java
│   │   └── CacheEventLogger.java
│   │
│   ├── persistence
│   │   ├── querydsl
│   │   │   └── QueryDslSupport.java
│   │   └── audit
│   │       └── AuditorAwareImpl.java
│   │
│   └── monitoring
│       ├── PerformanceLoggingAspect.java
│       └── CustomMetrics.java
│
└── util                            # 유틸리티
    ├── SecurityUtils.java
    ├── DateUtils.java
    └── StringUtils.java
```

## 4. 계층별 상세 설계

### 4.1 Presentation Layer (프레젠테이션 계층)

#### 책임
- HTTP 요청/응답 처리
- 입력 검증 (Bean Validation)
- DTO 변환
- 예외 처리

#### 주요 컴포넌트

**Controller**
```java
@RestController
@RequestMapping("/api/v1/posts")
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    @GetMapping
    public ApiResponse<PageResponse<PostResponse>> getPosts(
            @Valid PostSearchCondition condition,
            Pageable pageable) {
        return ApiResponse.success(postService.getPosts(condition, pageable));
    }

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ApiResponse<PostResponse> createPost(
            @Valid @RequestBody PostCreateRequest request,
            @CurrentUser UserPrincipal user) {
        return ApiResponse.success(postService.createPost(request, user.getId()));
    }
}
```

**Global Exception Handler**
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ApiResponse<Void>> handleDomainException(DomainException e) {
        return ResponseEntity
                .status(e.getErrorCode().getStatus())
                .body(ApiResponse.error(e.getErrorCode()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationException(
            MethodArgumentNotValidException e) {
        // 검증 에러 처리
    }
}
```

**Custom Argument Resolver**
```java
@Component
public class CurrentUserArgumentResolver implements HandlerMethodArgumentResolver {

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(CurrentUser.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter,
                                   ModelAndViewContainer mavContainer,
                                   NativeWebRequest webRequest,
                                   WebDataBinderFactory binderFactory) {
        // JWT에서 사용자 정보 추출
        return SecurityContextHolder.getContext()
                .getAuthentication()
                .getPrincipal();
    }
}
```

### 4.2 Application Layer (애플리케이션 계층)

#### 책임
- 비즈니스 로직 조율 (Orchestration)
- 트랜잭션 경계 설정
- 도메인 서비스 호출
- DTO 변환 (Entity ↔ DTO)

#### 주요 컴포넌트

**Service**
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class PostService {

    private final PostRepository postRepository;
    private final PostViewService postViewService;
    private final PostMapper postMapper;
    private final UserRepository userRepository;
    private final CategoryRepository categoryRepository;

    public PageResponse<PostResponse> getPosts(PostSearchCondition condition,
                                                Pageable pageable) {
        Page<Post> posts = postRepository.search(condition, pageable);
        return PageResponse.of(posts.map(postMapper::toResponse));
    }

    public PostDetailResponse getPost(Long postId, Long currentUserId) {
        Post post = postRepository.findByIdWithDetails(postId)
                .orElseThrow(() -> new PostNotFoundException(postId));

        // 비동기 조회수 증가
        postViewService.increaseViewCount(postId, currentUserId);

        return postMapper.toDetailResponse(post, currentUserId);
    }

    @Transactional
    public PostResponse createPost(PostCreateRequest request, Long authorId) {
        User author = userRepository.findById(authorId)
                .orElseThrow(() -> new UserNotFoundException(authorId));

        Category category = categoryRepository.findById(request.getCategoryId())
                .orElseThrow(() -> new CategoryNotFoundException(request.getCategoryId()));

        Post post = Post.builder()
                .title(request.getTitle())
                .content(request.getContent())
                .author(author)
                .category(category)
                .build();

        Post savedPost = postRepository.save(post);
        return postMapper.toResponse(savedPost);
    }

    @Transactional
    @CacheEvict(value = "posts", key = "#postId")
    public PostResponse updatePost(Long postId, PostUpdateRequest request, Long userId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException(postId));

        // 권한 검증
        if (!post.isAuthor(userId)) {
            throw new UnauthorizedException("게시글 수정 권한이 없습니다.");
        }

        post.update(request.getTitle(), request.getContent());

        return postMapper.toResponse(post);
    }
}
```

**DTO Mapper (MapStruct)**
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface PostMapper {

    @Mapping(source = "author.nickname", target = "authorNickname")
    @Mapping(source = "category.name", target = "categoryName")
    PostResponse toResponse(Post post);

    @Mapping(source = "author.nickname", target = "authorNickname")
    @Mapping(source = "category.name", target = "categoryName")
    @Mapping(target = "myReaction", expression = "java(getMyReaction(post, currentUserId))")
    PostDetailResponse toDetailResponse(Post post, Long currentUserId);

    default ReactionType getMyReaction(Post post, Long userId) {
        if (userId == null) return null;
        return post.getReactions().stream()
                .filter(r -> r.getUser().getId().equals(userId))
                .findFirst()
                .map(PostReaction::getReactionType)
                .orElse(null);
    }
}
```

### 4.3 Domain Layer (도메인 계층)

#### 책임
- 비즈니스 규칙 구현
- 도메인 로직 캡슐화
- 엔티티 상태 관리
- Repository 인터페이스 정의

#### 주요 컴포넌트

**Entity**
```java
@Entity
@Table(
    name = "posts",
    indexes = {
        @Index(name = "idx_category_deleted_created", columnList = "category_id, deleted_at, created_at"),
        @Index(name = "idx_deleted_view_count", columnList = "deleted_at, view_count DESC")
    }
)
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@EntityListeners(AuditingEntityListener.class)
public class Post extends BaseTimeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String title;

    @Lob
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", nullable = false)
    private User author;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    @Column(nullable = false)
    private Long viewCount = 0L;

    @Column(nullable = false)
    private Integer likeCount = 0;

    @Column(nullable = false)
    private Integer dislikeCount = 0;

    @Version
    private Long version;

    @Column
    private LocalDateTime deletedAt;

    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> comments = new ArrayList<>();

    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<PostReaction> reactions = new ArrayList<>();

    @Builder
    public Post(String title, String content, User author, Category category) {
        validateTitle(title);
        validateContent(content);
        this.title = title;
        this.content = content;
        this.author = author;
        this.category = category;
    }

    // 비즈니스 로직
    public void update(String title, String content) {
        validateTitle(title);
        validateContent(content);
        this.title = title;
        this.content = content;
    }

    public void delete() {
        this.deletedAt = LocalDateTime.now();
    }

    public boolean isDeleted() {
        return deletedAt != null;
    }

    public boolean isAuthor(Long userId) {
        return this.author.getId().equals(userId);
    }

    public void increaseViewCount() {
        this.viewCount++;
    }

    // 연관관계 편의 메서드
    public void addComment(Comment comment) {
        comments.add(comment);
        comment.setPost(this);
    }

    public void addReaction(PostReaction reaction) {
        reactions.add(reaction);
        reaction.setPost(this);
        updateReactionCount();
    }

    public void removeReaction(PostReaction reaction) {
        reactions.remove(reaction);
        updateReactionCount();
    }

    private void updateReactionCount() {
        this.likeCount = (int) reactions.stream()
                .filter(r -> r.getReactionType() == ReactionType.LIKE)
                .count();
        this.dislikeCount = (int) reactions.stream()
                .filter(r -> r.getReactionType() == ReactionType.DISLIKE)
                .count();
    }

    // 검증 로직
    private void validateTitle(String title) {
        if (title == null || title.trim().isEmpty()) {
            throw new InvalidPostException("제목은 필수입니다.");
        }
        if (title.length() < 2 || title.length() > 200) {
            throw new InvalidPostException("제목은 2-200자 이내여야 합니다.");
        }
    }

    private void validateContent(String content) {
        if (content == null || content.trim().isEmpty()) {
            throw new InvalidPostException("내용은 필수입니다.");
        }
        if (content.length() > 10000) {
            throw new InvalidPostException("내용은 10,000자 이하여야 합니다.");
        }
    }
}
```

**Base Entity**
```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
public abstract class BaseTimeEntity {

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
}
```

**Repository**
```java
public interface PostRepository extends JpaRepository<Post, Long>, PostRepositoryCustom {

    @Query("SELECT p FROM Post p " +
           "JOIN FETCH p.author " +
           "JOIN FETCH p.category " +
           "WHERE p.id = :id AND p.deletedAt IS NULL")
    Optional<Post> findByIdWithDetails(@Param("id") Long id);

    @EntityGraph(attributePaths = {"author", "category"})
    Page<Post> findByDeletedAtIsNull(Pageable pageable);
}

// Custom Repository for QueryDSL
public interface PostRepositoryCustom {
    Page<Post> search(PostSearchCondition condition, Pageable pageable);
    List<PostResponse> findPopularPosts(int limit);
}

@Repository
@RequiredArgsConstructor
public class PostRepositoryImpl implements PostRepositoryCustom {

    private final JPAQueryFactory queryFactory;

    @Override
    public Page<Post> search(PostSearchCondition condition, Pageable pageable) {
        QPost post = QPost.post;
        QUser author = QUser.user;
        QCategory category = QCategory.category;

        BooleanBuilder builder = new BooleanBuilder();
        builder.and(post.deletedAt.isNull());

        if (condition.getCategoryId() != null) {
            builder.and(post.category.id.eq(condition.getCategoryId()));
        }

        if (StringUtils.hasText(condition.getKeyword())) {
            BooleanExpression keywordExpression = switch (condition.getSearchType()) {
                case TITLE -> post.title.containsIgnoreCase(condition.getKeyword());
                case CONTENT -> post.content.containsIgnoreCase(condition.getKeyword());
                case AUTHOR -> author.nickname.containsIgnoreCase(condition.getKeyword());
                case ALL -> post.title.containsIgnoreCase(condition.getKeyword())
                        .or(post.content.containsIgnoreCase(condition.getKeyword()));
            };
            builder.and(keywordExpression);
        }

        List<Post> content = queryFactory
                .selectFrom(post)
                .join(post.author, author).fetchJoin()
                .join(post.category, category).fetchJoin()
                .where(builder)
                .orderBy(getOrderSpecifier(condition.getSortBy()))
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();

        Long total = queryFactory
                .select(post.count())
                .from(post)
                .where(builder)
                .fetchOne();

        return new PageImpl<>(content, pageable, total != null ? total : 0);
    }

    private OrderSpecifier<?> getOrderSpecifier(SortType sortBy) {
        QPost post = QPost.post;
        return switch (sortBy) {
            case LATEST -> post.createdAt.desc();
            case VIEW_COUNT -> post.viewCount.desc();
            case LIKE_COUNT -> post.likeCount.desc();
        };
    }
}
```

**Domain Service**
```java
@Service
@RequiredArgsConstructor
public class PostDomainService {

    private final PostReactionRepository postReactionRepository;

    @Transactional
    public void toggleReaction(Post post, User user, ReactionType newReactionType) {
        Optional<PostReaction> existingReaction = postReactionRepository
                .findByPostAndUser(post, user);

        if (existingReaction.isPresent()) {
            PostReaction reaction = existingReaction.get();
            if (reaction.getReactionType() == newReactionType) {
                // 같은 반응이면 취소
                post.removeReaction(reaction);
                postReactionRepository.delete(reaction);
            } else {
                // 다른 반응이면 변경
                reaction.changeReactionType(newReactionType);
                post.updateReactionCount();
            }
        } else {
            // 새로운 반응 추가
            PostReaction newReaction = PostReaction.builder()
                    .post(post)
                    .user(user)
                    .reactionType(newReactionType)
                    .build();
            post.addReaction(newReaction);
            postReactionRepository.save(newReaction);
        }
    }
}
```

### 4.4 Infrastructure Layer (인프라 계층)

#### 책임
- 외부 시스템 연동 (DB, Cache, 외부 API)
- 프레임워크 설정
- 보안 설정
- 모니터링 설정

#### 주요 컴포넌트

**JPA Configuration**
```java
@Configuration
@EnableJpaAuditing
@EnableJpaRepositories(
    basePackages = "com.board.domain",
    repositoryImplementationPostfix = "Impl"
)
public class JpaConfig {

    @Bean
    public AuditorAware<Long> auditorProvider() {
        return new AuditorAwareImpl();
    }
}
```

**Redis Configuration**
```java
@Configuration
@EnableCaching
@EnableRedisRepositories
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        return new LettuceConnectionFactory(config);
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory());
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }

    @Bean
    public CacheManager cacheManager() {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(redisConnectionFactory())
                .cacheDefaults(config)
                .withCacheConfiguration("posts", config.entryTtl(Duration.ofMinutes(10)))
                .withCacheConfiguration("categories", config.entryTtl(Duration.ofHours(1)))
                .build();
    }
}
```

**Security Configuration**
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final JwtAccessDeniedHandler jwtAccessDeniedHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .sessionManagement(session -> session
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .exceptionHandling(exception -> exception
                    .authenticationEntryPoint(jwtAuthenticationEntryPoint)
                    .accessDeniedHandler(jwtAccessDeniedHandler))
            .authorizeHttpRequests(auth -> auth
                    .requestMatchers("/api/v1/auth/**").permitAll()
                    .requestMatchers(HttpMethod.GET, "/api/v1/posts/**").permitAll()
                    .requestMatchers(HttpMethod.GET, "/api/v1/comments/**").permitAll()
                    .requestMatchers(HttpMethod.GET, "/api/v1/categories/**").permitAll()
                    .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                    .requestMatchers("/actuator/**").hasRole("ADMIN")
                    .anyRequest().authenticated())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:3000"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "PATCH"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
```

**JWT Filter**
```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                     HttpServletResponse response,
                                     FilterChain filterChain) throws ServletException, IOException {
        String token = resolveToken(request);

        if (StringUtils.hasText(token) && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsername(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

**Async Configuration (Virtual Threads)**
```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)
    public AsyncTaskExecutor asyncTaskExecutor() {
        // Java 21 Virtual Threads 활용
        TaskExecutorAdapter adapter = new TaskExecutorAdapter(
                Executors.newVirtualThreadPerTaskExecutor());
        adapter.setTaskDecorator(new MDCTaskDecorator());
        return adapter;
    }

    // MDC 컨텍스트 전파
    private static class MDCTaskDecorator implements TaskDecorator {
        @Override
        public Runnable decorate(Runnable runnable) {
            Map<String, String> contextMap = MDC.getCopyOfContextMap();
            return () -> {
                try {
                    if (contextMap != null) {
                        MDC.setContextMap(contextMap);
                    }
                    runnable.run();
                } finally {
                    MDC.clear();
                }
            };
        }
    }
}
```

**Performance Logging Aspect**
```java
@Aspect
@Component
@Slf4j
public class PerformanceLoggingAspect {

    @Around("@annotation(com.board.infrastructure.monitoring.LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();

        try {
            Object result = joinPoint.proceed();
            long executionTime = System.currentTimeMillis() - start;

            log.info("Method: {} executed in {} ms",
                    joinPoint.getSignature().toShortString(),
                    executionTime);

            return result;
        } catch (Throwable throwable) {
            long executionTime = System.currentTimeMillis() - start;
            log.error("Method: {} failed after {} ms",
                    joinPoint.getSignature().toShortString(),
                    executionTime,
                    throwable);
            throw throwable;
        }
    }
}
```

## 5. 데이터베이스 스키마

### 5.1 ERD

```
┌─────────────────┐       ┌──────────────────┐
│     users       │       │    categories    │
├─────────────────┤       ├──────────────────┤
│ id (PK)         │       │ id (PK)          │
│ email (UK)      │       │ name (UK)        │
│ password        │       │ description      │
│ nickname (UK)   │       │ display_order    │
│ role            │       │ created_at       │
│ status          │       │ updated_at       │
│ failed_login... │       └──────────────────┘
│ locked_until    │                │
│ created_at      │                │
│ updated_at      │                │
│ withdrawn_at    │                │
└─────────────────┘                │
         │                         │
         │ author_id      category_id
         │                         │
         └────┬────────────────────┘
              │
      ┌───────▼───────────┐
      │      posts        │
      ├───────────────────┤
      │ id (PK)           │
      │ title             │
      │ content (TEXT)    │
      │ author_id (FK)    │
      │ category_id (FK)  │
      │ view_count        │
      │ like_count        │
      │ dislike_count     │
      │ version           │
      │ created_at        │
      │ updated_at        │
      │ deleted_at        │
      └───────────────────┘
         │            │
         │            └──────────────┐
         │                           │
         │ post_id                   │ post_id
         │                           │
┌────────▼──────────┐      ┌─────────▼──────────┐
│    comments       │      │  post_reactions    │
├───────────────────┤      ├────────────────────┤
│ id (PK)           │      │ id (PK)            │
│ content           │      │ user_id (FK)       │
│ author_id (FK)    │      │ post_id (FK)       │
│ post_id (FK)      │      │ reaction_type      │
│ parent_id (FK)    │◄─┐   │ created_at         │
│ depth             │  │   │ updated_at         │
│ like_count        │  │   │ UK(user_id,        │
│ dislike_count     │  │   │    post_id)        │
│ is_deleted        │  │   └────────────────────┘
│ version           │  │
│ created_at        │  │   ┌────────────────────┐
│ updated_at        │  │   │ comment_reactions  │
│ deleted_at        │  │   ├────────────────────┤
└───────────────────┘  │   │ id (PK)            │
         │             │   │ user_id (FK)       │
         │ parent_id   │   │ comment_id (FK)    │
         └─────────────┘   │ reaction_type      │
         │                 │ created_at         │
         │ comment_id      │ updated_at         │
         └────────────────►│ UK(user_id,        │
                           │    comment_id)     │
                           └────────────────────┘

┌────────────────────┐
│    post_views      │
├────────────────────┤
│ id (PK)            │
│ user_id (FK)       │
│ post_id (FK)       │
│ viewed_at          │
│ ip_address         │
└────────────────────┘
```

### 5.2 테이블 정의서

#### users 테이블
```sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    nickname VARCHAR(50) NOT NULL UNIQUE,
    role VARCHAR(20) NOT NULL DEFAULT 'USER',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    failed_login_attempts INT NOT NULL DEFAULT 0,
    locked_until DATETIME,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    withdrawn_at DATETIME,
    INDEX idx_status_created (status, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### categories 테이블
```sql
CREATE TABLE categories (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description VARCHAR(500),
    display_order INT NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_display_order (display_order)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### posts 테이블
```sql
CREATE TABLE posts (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    category_id BIGINT NOT NULL,
    view_count BIGINT NOT NULL DEFAULT 0,
    like_count INT NOT NULL DEFAULT 0,
    dislike_count INT NOT NULL DEFAULT 0,
    version BIGINT NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at DATETIME,
    FOREIGN KEY (author_id) REFERENCES users(id),
    FOREIGN KEY (category_id) REFERENCES categories(id),
    INDEX idx_category_deleted_created (category_id, deleted_at, created_at),
    INDEX idx_author_deleted (author_id, deleted_at),
    INDEX idx_deleted_view_count (deleted_at, view_count DESC),
    INDEX idx_deleted_like_count (deleted_at, like_count DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### comments 테이블
```sql
CREATE TABLE comments (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    content VARCHAR(1000) NOT NULL,
    author_id BIGINT NOT NULL,
    post_id BIGINT NOT NULL,
    parent_comment_id BIGINT,
    depth INT NOT NULL DEFAULT 0,
    like_count INT NOT NULL DEFAULT 0,
    dislike_count INT NOT NULL DEFAULT 0,
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
    version BIGINT NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at DATETIME,
    FOREIGN KEY (author_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES categories(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id),
    INDEX idx_post_deleted_created (post_id, deleted_at, created_at),
    INDEX idx_parent_comment (parent_comment_id),
    INDEX idx_author_deleted (author_id, deleted_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### post_reactions 테이블
```sql
CREATE TABLE post_reactions (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    post_id BIGINT NOT NULL,
    reaction_type VARCHAR(20) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_post (user_id, post_id),
    INDEX idx_post_reaction (post_id, reaction_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### comment_reactions 테이블
```sql
CREATE TABLE comment_reactions (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    comment_id BIGINT NOT NULL,
    reaction_type VARCHAR(20) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_comment (user_id, comment_id),
    INDEX idx_comment_reaction (comment_id, reaction_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### post_views 테이블
```sql
CREATE TABLE post_views (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT,
    post_id BIGINT NOT NULL,
    viewed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    INDEX idx_user_post_viewed (user_id, post_id, viewed_at),
    INDEX idx_ip_post_viewed (ip_address, post_id, viewed_at),
    INDEX idx_post_viewed (post_id, viewed_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

## 6. JVM 최적화 전략

### 6.1 JVM 파라미터 설정

```bash
# Heap 크기
-Xms2g
-Xmx2g  # 초기와 최대를 동일하게 설정하여 리사이징 방지

# GC 설정 (G1GC)
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=8m
-XX:InitiatingHeapOccupancyPercent=45

# Metaspace
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m

# GC 로깅
-Xlog:gc*:file=/var/log/gc.log:time,uptime,level,tags:filecount=10,filesize=100M

# JFR (Java Flight Recorder)
-XX:StartFlightRecording=disk=true,dumponexit=true,filename=/var/log/flight.jfr

# Virtual Threads 최적화
-Djdk.virtualThreadScheduler.parallelism=10
-Djdk.virtualThreadScheduler.maxPoolSize=256
```

### 6.2 성능 모니터링 메트릭

- **Heap 사용률**: 70% 이하 유지
- **GC Pause Time**: 200ms 이하
- **GC Frequency**: Minor GC 1초당 1회 이하
- **Thread Count**: 안정적인 수치 유지 (Virtual Threads 활용)
- **DB Connection Pool**: 70% 이하 사용률

### 6.3 프로파일링 전략

1. **JFR로 지속적 모니터링**
   - CPU 사용률
   - 메모리 할당 패턴
   - 락 경합 (Lock Contention)

2. **VisualVM/JConsole**
   - 실시간 Heap 모니터링
   - Thread Dump 분석

3. **Async Profiler**
   - Flame Graph로 핫스팟 식별

## 7. 배포 및 운영

### 7.1 환경별 설정

```yaml
# application.yml
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}

---
# application-dev.yml
spring:
  config:
    activate:
      on-profile: dev
  datasource:
    url: jdbc:h2:mem:testdb
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
logging:
  level:
    com.board: DEBUG

---
# application-prod.yml
spring:
  config:
    activate:
      on-profile: prod
  datasource:
    url: jdbc:mysql://prod-db:3306/board
    hikari:
      maximum-pool-size: 20
      minimum-idle: 10
  jpa:
    show-sql: false
    properties:
      hibernate:
        format_sql: false
        generate_statistics: false
logging:
  level:
    com.board: INFO
```

### 7.2 헬스 체크

```java
@Component
public class CustomHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        // DB 연결 확인
        // Redis 연결 확인
        // 기타 외부 의존성 확인
        return Health.up()
                .withDetail("database", "UP")
                .withDetail("redis", "UP")
                .build();
    }
}
```

## 8. 테스트 전략

### 8.1 테스트 피라미드

```
        ┌────────┐
        │  E2E   │  (5%)
        └────────┘
      ┌──────────────┐
      │ Integration  │  (15%)
      └──────────────┘
    ┌──────────────────┐
    │   Unit Tests     │  (80%)
    └──────────────────┘
```

### 8.2 테스트 구조

```java
// 단위 테스트
@ExtendWith(MockitoExtension.class)
class PostServiceTest {

    @Mock
    private PostRepository postRepository;

    @InjectMocks
    private PostService postService;

    @Test
    void createPost_Success() {
        // given
        // when
        // then
    }
}

// 통합 테스트
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class PostIntegrationTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0");

    @Autowired
    private PostService postService;

    @Test
    void createPost_IntegrationTest() {
        // given
        // when
        // then
    }
}

// API 테스트
@WebMvcTest(PostController.class)
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private PostService postService;

    @Test
    @WithMockUser
    void createPost_API_Success() throws Exception {
        mockMvc.perform(post("/api/v1/posts")
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                        "title": "테스트",
                        "content": "내용",
                        "categoryId": 1
                    }
                    """))
                .andExpect(status().isCreated())
                .andDo(document("post-create"));
    }
}
```

## 9. 기술 부채 관리

### 9.1 코드 품질 도구
- **SonarQube**: 정적 코드 분석
- **SpotBugs**: 버그 패턴 검출
- **Checkstyle**: 코드 스타일 검증

### 9.2 의존성 관리
- 정기적인 라이브러리 업데이트
- 보안 취약점 스캔 (OWASP Dependency-Check)

## 10. 확장 고려사항

### 10.1 마이크로서비스 전환 대비
- 도메인별 모듈 분리 구조
- API Gateway 패턴 적용 가능

### 10.2 이벤트 기반 아키텍처
- Spring Events로 도메인 이벤트 처리
- 추후 Kafka/RabbitMQ 연동 가능

### 10.3 CQRS 패턴
- 읽기/쓰기 분리 가능한 구조
- Read Model 최적화

이상으로 게시판 프로젝트의 아키텍처 설계를 완료했습니다.
