# 게시판 프로젝트 기획서

## 1. 프로젝트 배경 및 목적

### 1.1 배경
최신 Java/Spring 기술 스택을 활용하여 엔터프라이즈급 애플리케이션 개발 역량을 보여주기 위한 포트폴리오 프로젝트입니다.
단순한 CRUD 구현이 아닌, 실무에서 요구되는 성능 최적화, 동시성 제어, 확장 가능한 아키텍처 설계 등을 종합적으로 적용합니다.

### 1.2 목적
- Java 21의 최신 기능 활용 (Virtual Threads, Record, Pattern Matching 등)
- JVM 내부 동작 이해 및 성능 튜닝 경험
- 고급 JPA 기법 적용 (N+1 해결, 쿼리 최적화, 캐싱 전략 등)
- Spring 생태계 기술 종합 활용
- 실무 수준의 코드 품질 및 테스트 커버리지 확보

## 2. 도메인 모델 설계

### 2.1 핵심 엔티티

#### 2.1.1 User (사용자)
```
- id (Long): 기본키
- email (String): 이메일 (고유, NOT NULL)
- password (String): 암호화된 비밀번호 (NOT NULL)
- nickname (String): 닉네임 (고유, NOT NULL)
- role (Role): 역할 (ADMIN, USER)
- status (UserStatus): 상태 (ACTIVE, LOCKED, WITHDRAWN)
- failedLoginAttempts (int): 로그인 실패 횟수
- lockedUntil (LocalDateTime): 계정 잠금 해제 시각
- createdAt (LocalDateTime): 생성일시
- updatedAt (LocalDateTime): 수정일시
- withdrawnAt (LocalDateTime): 탈퇴일시
```

#### 2.1.2 Category (카테고리)
```
- id (Long): 기본키
- name (String): 카테고리명 (고유, NOT NULL)
- description (String): 설명
- displayOrder (int): 표시 순서
- createdAt (LocalDateTime): 생성일시
- updatedAt (LocalDateTime): 수정일시
```

#### 2.1.3 Post (게시글)
```
- id (Long): 기본키
- title (String): 제목 (NOT NULL)
- content (String): 내용 (NOT NULL, TEXT)
- author (User): 작성자 (ManyToOne)
- category (Category): 카테고리 (ManyToOne)
- viewCount (Long): 조회수
- likeCount (int): 좋아요 수
- dislikeCount (int): 싫어요 수
- version (Long): 낙관적 락용 버전
- createdAt (LocalDateTime): 작성일시
- updatedAt (LocalDateTime): 수정일시
- deletedAt (LocalDateTime): 삭제일시 (소프트 삭제)
```

#### 2.1.4 Comment (댓글)
```
- id (Long): 기본키
- content (String): 내용 (NOT NULL)
- author (User): 작성자 (ManyToOne)
- post (Post): 게시글 (ManyToOne)
- parentComment (Comment): 부모 댓글 (ManyToOne, Self-Join)
- childComments (List<Comment>): 자식 댓글들 (OneToMany)
- depth (int): 댓글 깊이 (0: 최상위)
- likeCount (int): 좋아요 수
- dislikeCount (int): 싫어요 수
- isDeleted (boolean): 삭제 여부
- version (Long): 낙관적 락용 버전
- createdAt (LocalDateTime): 작성일시
- updatedAt (LocalDateTime): 수정일시
- deletedAt (LocalDateTime): 삭제일시
```

#### 2.1.5 PostReaction (게시글 좋아요/싫어요)
```
- id (Long): 기본키
- user (User): 사용자 (ManyToOne)
- post (Post): 게시글 (ManyToOne)
- reactionType (ReactionType): 반응 타입 (LIKE, DISLIKE)
- createdAt (LocalDateTime): 생성일시
- updatedAt (LocalDateTime): 수정일시
- 복합 유니크 제약: (user_id, post_id)
```

#### 2.1.6 CommentReaction (댓글 좋아요/싫어요)
```
- id (Long): 기본키
- user (User): 사용자 (ManyToOne)
- comment (Comment): 댓글 (ManyToOne)
- reactionType (ReactionType): 반응 타입 (LIKE, DISLIKE)
- createdAt (LocalDateTime): 생성일시
- updatedAt (LocalDateTime): 수정일시
- 복합 유니크 제약: (user_id, comment_id)
```

#### 2.1.7 PostView (게시글 조회 기록)
```
- id (Long): 기본키
- user (User): 사용자 (ManyToOne, nullable)
- post (Post): 게시글 (ManyToOne)
- viewedAt (LocalDateTime): 조회일시
- ipAddress (String): IP 주소 (비회원 중복 방지용)
- 복합 인덱스: (user_id, post_id, viewedAt) 또는 (ip_address, post_id, viewedAt)
```

### 2.2 Enum 정의

#### Role
```java
public enum Role {
    USER,   // 일반 사용자
    ADMIN   // 관리자
}
```

#### UserStatus
```java
public enum UserStatus {
    ACTIVE,     // 정상
    LOCKED,     // 잠금
    WITHDRAWN   // 탈퇴
}
```

#### ReactionType
```java
public enum ReactionType {
    LIKE,       // 좋아요
    DISLIKE     // 싫어요
}
```

### 2.3 연관관계 설계

#### 양방향 연관관계
- Post ↔ Comment: OneToMany / ManyToOne
- Comment ↔ Comment: OneToMany / ManyToOne (자기 참조)

#### 단방향 연관관계
- User ← Post: ManyToOne (게시글이 작성자 참조)
- User ← Comment: ManyToOne (댓글이 작성자 참조)
- Category ← Post: ManyToOne (게시글이 카테고리 참조)
- User ← PostReaction → Post: ManyToOne (다대다 중간 테이블)
- User ← CommentReaction → Comment: ManyToOne (다대다 중간 테이블)

#### 연관관계 설정 이유
- 양방향 연관관계는 편의 메서드를 통해 양쪽 동기화
- 대부분 단방향으로 설계하여 복잡도 감소
- 필요한 경우 쿼리를 통해 역방향 조회

### 2.4 인덱스 전략

#### User 테이블
- PRIMARY KEY: id
- UNIQUE INDEX: email
- UNIQUE INDEX: nickname
- INDEX: (status, createdAt) - 활성 사용자 조회

#### Post 테이블
- PRIMARY KEY: id
- INDEX: (category_id, deletedAt, createdAt) - 카테고리별 최신글 조회
- INDEX: (author_id, deletedAt) - 작성자별 게시글 조회
- INDEX: (deletedAt, viewCount DESC) - 인기글 조회
- INDEX: (deletedAt, likeCount DESC) - 좋아요순 조회
- FULLTEXT INDEX: (title, content) - 전문 검색 (선택)

#### Comment 테이블
- PRIMARY KEY: id
- INDEX: (post_id, deletedAt, createdAt) - 게시글별 댓글 조회
- INDEX: (parent_comment_id) - 대댓글 조회
- INDEX: (author_id, deletedAt) - 작성자별 댓글 조회

#### PostReaction 테이블
- PRIMARY KEY: id
- UNIQUE INDEX: (user_id, post_id) - 중복 방지
- INDEX: (post_id, reactionType) - 게시글별 반응 집계

#### CommentReaction 테이블
- PRIMARY KEY: id
- UNIQUE INDEX: (user_id, comment_id) - 중복 방지
- INDEX: (comment_id, reactionType) - 댓글별 반응 집계

#### PostView 테이블
- PRIMARY KEY: id
- INDEX: (user_id, post_id, viewedAt) - 사용자별 조회 기록
- INDEX: (ip_address, post_id, viewedAt) - IP별 조회 기록
- INDEX: (post_id, viewedAt) - 게시글별 조회 통계

## 3. API 설계

### 3.1 API 명명 규칙
- RESTful API 원칙 준수
- URL은 소문자, 단어 구분은 하이픈(-) 사용
- 복수형 명사 사용 (/posts, /comments)
- 버전 관리: /api/v1/...

### 3.2 공통 응답 형식

#### 성공 응답
```json
{
  "success": true,
  "data": { ... },
  "message": "Success"
}
```

#### 실패 응답
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "에러 메시지",
    "details": [ ... ]
  }
}
```

#### 페이징 응답
```json
{
  "success": true,
  "data": {
    "content": [ ... ],
    "pageable": {
      "pageNumber": 0,
      "pageSize": 20,
      "totalPages": 10,
      "totalElements": 200
    }
  }
}
```

### 3.3 인증 API

#### POST /api/v1/auth/signup
회원가입
```
Request Body:
{
  "email": "user@example.com",
  "password": "password123!",
  "nickname": "사용자닉네임"
}

Response: 201 Created
{
  "success": true,
  "data": {
    "userId": 1,
    "email": "user@example.com",
    "nickname": "사용자닉네임",
    "role": "USER"
  }
}
```

#### POST /api/v1/auth/login
로그인
```
Request Body:
{
  "email": "user@example.com",
  "password": "password123!"
}

Response: 200 OK
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGc...",
    "refreshToken": "eyJhbGc...",
    "tokenType": "Bearer",
    "expiresIn": 3600
  }
}
```

#### POST /api/v1/auth/refresh
토큰 갱신
```
Request Body:
{
  "refreshToken": "eyJhbGc..."
}

Response: 200 OK
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGc...",
    "tokenType": "Bearer",
    "expiresIn": 3600
  }
}
```

#### POST /api/v1/auth/logout
로그아웃
```
Request Header: Authorization: Bearer {accessToken}

Response: 200 OK
{
  "success": true,
  "message": "로그아웃되었습니다."
}
```

### 3.4 사용자 API

#### GET /api/v1/users/me
내 정보 조회
```
Request Header: Authorization: Bearer {accessToken}

Response: 200 OK
{
  "success": true,
  "data": {
    "userId": 1,
    "email": "user@example.com",
    "nickname": "사용자닉네임",
    "role": "USER",
    "createdAt": "2025-01-01T00:00:00"
  }
}
```

#### PATCH /api/v1/users/me
내 정보 수정
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "nickname": "새닉네임"
}

Response: 200 OK
{
  "success": true,
  "data": {
    "userId": 1,
    "nickname": "새닉네임"
  }
}
```

#### PUT /api/v1/users/me/password
비밀번호 변경
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "currentPassword": "oldPassword123!",
  "newPassword": "newPassword123!"
}

Response: 200 OK
{
  "success": true,
  "message": "비밀번호가 변경되었습니다."
}
```

#### DELETE /api/v1/users/me
회원 탈퇴
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "password": "password123!"
}

Response: 200 OK
{
  "success": true,
  "message": "회원 탈퇴가 완료되었습니다."
}
```

### 3.5 카테고리 API

#### GET /api/v1/categories
카테고리 목록 조회
```
Response: 200 OK
{
  "success": true,
  "data": [
    {
      "categoryId": 1,
      "name": "자유게시판",
      "description": "자유롭게 글을 작성하세요",
      "postCount": 150,
      "displayOrder": 1
    }
  ]
}
```

#### POST /api/v1/categories (ADMIN)
카테고리 생성
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "name": "공지사항",
  "description": "중요한 공지사항",
  "displayOrder": 0
}

Response: 201 Created
{
  "success": true,
  "data": {
    "categoryId": 2,
    "name": "공지사항",
    "description": "중요한 공지사항",
    "displayOrder": 0
  }
}
```

#### PUT /api/v1/categories/{categoryId} (ADMIN)
카테고리 수정

#### DELETE /api/v1/categories/{categoryId} (ADMIN)
카테고리 삭제

### 3.6 게시글 API

#### GET /api/v1/posts
게시글 목록 조회
```
Query Parameters:
- categoryId: 카테고리 ID (optional)
- keyword: 검색 키워드 (optional)
- searchType: 검색 타입 (title, content, author) (optional)
- sortBy: 정렬 기준 (latest, viewCount, likeCount) (default: latest)
- page: 페이지 번호 (default: 0)
- size: 페이지 크기 (default: 20)

Response: 200 OK
{
  "success": true,
  "data": {
    "content": [
      {
        "postId": 1,
        "title": "게시글 제목",
        "author": {
          "userId": 1,
          "nickname": "작성자"
        },
        "category": {
          "categoryId": 1,
          "name": "자유게시판"
        },
        "viewCount": 100,
        "likeCount": 10,
        "dislikeCount": 2,
        "commentCount": 5,
        "createdAt": "2025-01-01T00:00:00"
      }
    ],
    "pageable": {
      "pageNumber": 0,
      "pageSize": 20,
      "totalPages": 10,
      "totalElements": 200
    }
  }
}
```

#### GET /api/v1/posts/{postId}
게시글 상세 조회
```
Response: 200 OK
{
  "success": true,
  "data": {
    "postId": 1,
    "title": "게시글 제목",
    "content": "게시글 내용...",
    "author": {
      "userId": 1,
      "nickname": "작성자"
    },
    "category": {
      "categoryId": 1,
      "name": "자유게시판"
    },
    "viewCount": 101,
    "likeCount": 10,
    "dislikeCount": 2,
    "myReaction": "LIKE",  // 현재 사용자의 반응 (없으면 null)
    "createdAt": "2025-01-01T00:00:00",
    "updatedAt": "2025-01-01T01:00:00"
  }
}
```

#### POST /api/v1/posts
게시글 작성
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "title": "게시글 제목",
  "content": "게시글 내용...",
  "categoryId": 1
}

Response: 201 Created
{
  "success": true,
  "data": {
    "postId": 1,
    "title": "게시글 제목",
    "content": "게시글 내용..."
  }
}
```

#### PUT /api/v1/posts/{postId}
게시글 수정

#### DELETE /api/v1/posts/{postId}
게시글 삭제

### 3.7 댓글 API

#### GET /api/v1/posts/{postId}/comments
게시글 댓글 조회
```
Query Parameters:
- page: 페이지 번호 (default: 0)
- size: 페이지 크기 (default: 50)

Response: 200 OK
{
  "success": true,
  "data": {
    "content": [
      {
        "commentId": 1,
        "content": "댓글 내용",
        "author": {
          "userId": 1,
          "nickname": "작성자"
        },
        "depth": 0,
        "likeCount": 5,
        "dislikeCount": 1,
        "myReaction": null,
        "isDeleted": false,
        "childComments": [
          {
            "commentId": 2,
            "content": "대댓글 내용",
            "depth": 1,
            ...
          }
        ],
        "createdAt": "2025-01-01T00:00:00"
      }
    ],
    "pageable": { ... }
  }
}
```

#### POST /api/v1/posts/{postId}/comments
댓글 작성
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "content": "댓글 내용",
  "parentCommentId": null  // 대댓글인 경우 부모 댓글 ID
}

Response: 201 Created
{
  "success": true,
  "data": {
    "commentId": 1,
    "content": "댓글 내용",
    "depth": 0
  }
}
```

#### PUT /api/v1/comments/{commentId}
댓글 수정

#### DELETE /api/v1/comments/{commentId}
댓글 삭제

### 3.8 좋아요/싫어요 API

#### POST /api/v1/posts/{postId}/reactions
게시글 좋아요/싫어요
```
Request Header: Authorization: Bearer {accessToken}
Request Body:
{
  "reactionType": "LIKE"  // LIKE or DISLIKE
}

Response: 200 OK
{
  "success": true,
  "data": {
    "reactionType": "LIKE",
    "likeCount": 11,
    "dislikeCount": 2
  }
}
```

#### DELETE /api/v1/posts/{postId}/reactions
게시글 좋아요/싫어요 취소

#### POST /api/v1/comments/{commentId}/reactions
댓글 좋아요/싫어요

#### DELETE /api/v1/comments/{commentId}/reactions
댓글 좋아요/싫어요 취소

## 4. 기술적 설계 방향

### 4.1 계층형 댓글 처리 전략

#### 방안 1: 인접 리스트 (Adjacency List) ✅ 채택
- 각 댓글이 부모 댓글 ID를 가지는 방식
- 장점: 구현 간단, 삽입/수정/삭제 빠름
- 단점: 전체 트리 조회 시 재귀 쿼리 또는 N+1 발생 가능
- 해결: Fetch Join + 애플리케이션에서 트리 구성

```sql
-- Fetch Join으로 한 번에 조회
SELECT c FROM Comment c
LEFT JOIN FETCH c.author
WHERE c.post.id = :postId AND c.deletedAt IS NULL
ORDER BY c.createdAt ASC
```

#### 방안 2: 경로 열거 (Path Enumeration)
- 각 댓글이 루트부터의 경로를 저장 (예: "1/3/5")
- 장점: 특정 브랜치 조회 용이
- 단점: 경로 길이 제한, 업데이트 복잡
- 결론: 복잡도 대비 이점이 크지 않아 미채택

#### 방안 3: Nested Set
- 각 노드가 left, right 값을 가짐
- 장점: 전체 서브트리 조회 빠름
- 단점: 삽입/삭제 시 대량 업데이트 필요
- 결론: 쓰기 작업이 많은 댓글에 부적합하여 미채택

### 4.2 조회수 처리 전략

#### 문제
- 높은 빈도의 UPDATE 쿼리 발생
- 동시성 이슈 (Race Condition)
- DB 부하 증가

#### 해결 방안 ✅
1. **Redis 카운터 활용**
   - Redis에서 조회수 증가 (INCR 명령)
   - 일정 주기(예: 1분)마다 배치로 DB에 반영
   - 동일 사용자 중복 방지: Redis Set 활용 (24시간 TTL)

2. **낙관적 락 활용**
   - Post 엔티티에 @Version 추가
   - 동시 수정 시 재시도 로직

3. **비동기 처리**
   - @Async를 활용한 비동기 조회수 증가
   - 트랜잭션 분리

```java
// 예시 코드 구조
@Service
public class PostViewService {

    @Async
    public void increaseViewCount(Long postId, Long userId, String ipAddress) {
        String key = "post:view:" + postId + ":" + (userId != null ? userId : ipAddress);

        // 24시간 내 중복 체크
        if (redisTemplate.opsForValue().setIfAbsent(key, "1", 24, TimeUnit.HOURS)) {
            // Redis 카운터 증가
            redisTemplate.opsForValue().increment("post:viewcount:" + postId);
        }
    }

    @Scheduled(fixedDelay = 60000) // 1분마다
    public void syncViewCountToDB() {
        // Redis 카운터를 DB에 동기화
    }
}
```

### 4.3 좋아요/싫어요 동시성 제어

#### 문제
- 여러 사용자가 동시에 좋아요/싫어요 시 카운트 불일치

#### 해결 방안 ✅
1. **낙관적 락 (Optimistic Lock)**
   - Post, Comment 엔티티에 @Version 추가
   - 충돌 시 재시도 로직
   - 읽기가 많고 쓰기가 적을 때 유리

2. **집계 쿼리 활용**
   - likeCount, dislikeCount를 매번 계산
   - 정확도 높음, 성능은 인덱스로 보완

```java
// 조회 시 실시간 집계
SELECT
  p.id,
  COUNT(CASE WHEN pr.reactionType = 'LIKE' THEN 1 END) as likeCount,
  COUNT(CASE WHEN pr.reactionType = 'DISLIKE' THEN 1 END) as dislikeCount
FROM Post p
LEFT JOIN PostReaction pr ON p.id = pr.post.id
GROUP BY p.id
```

3. **이벤트 기반 캐시 무효화**
   - 좋아요/싫어요 변경 시 해당 게시글/댓글 캐시 무효화
   - @CacheEvict 활용

### 4.4 캐싱 전략

#### 3단계 캐싱
1. **로컬 캐시 (Ehcache) - 1차**
   - 카테고리 목록 (변경 빈도 낮음)
   - 사용자 권한 정보
   - TTL: 5분

2. **분산 캐시 (Redis) - 2차**
   - 게시글 상세 정보
   - 인기 게시글 목록
   - TTL: 10분

3. **데이터베이스 쿼리 캐시 - 3차**
   - Hibernate 2차 캐시
   - 읽기 전용 엔티티

#### 캐시 무효화 전략
- Write-Through: 데이터 변경 시 즉시 캐시 갱신
- Cache-Aside: 캐시 미스 시 DB 조회 후 캐시 저장
- 이벤트 기반 무효화: 게시글 수정/삭제 시 관련 캐시 제거

```java
@Cacheable(value = "posts", key = "#postId")
public PostDetailResponse getPost(Long postId) {
    // ...
}

@CacheEvict(value = "posts", key = "#postId")
public void updatePost(Long postId, PostUpdateRequest request) {
    // ...
}
```

### 4.5 쿼리 최적화 전략

#### N+1 문제 해결
1. **Fetch Join 활용**
```java
@Query("SELECT p FROM Post p " +
       "JOIN FETCH p.author " +
       "JOIN FETCH p.category " +
       "WHERE p.deletedAt IS NULL")
List<Post> findAllWithAuthorAndCategory();
```

2. **Entity Graph 활용**
```java
@EntityGraph(attributePaths = {"author", "category"})
List<Post> findByDeletedAtIsNull();
```

3. **Batch Size 설정**
```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

#### DTO Projection
- 목록 조회 시 필요한 필드만 조회
- Interface-based Projection 또는 Class-based Projection

```java
public interface PostSummaryProjection {
    Long getId();
    String getTitle();
    String getAuthorNickname();
    Long getViewCount();
}
```

#### 동적 쿼리
- QueryDSL을 활용한 타입 안전 쿼리
- Specification 패턴으로 복잡한 검색 조건 처리

### 4.6 트랜잭션 관리

#### 트랜잭션 분리
- 읽기 전용 트랜잭션: @Transactional(readOnly = true)
- 쓰기 트랜잭션: 최소 범위로 제한
- 조회수 증가: 별도 트랜잭션 (비동기)

#### 트랜잭션 전파
- REQUIRED: 기본 (기존 트랜잭션 참여)
- REQUIRES_NEW: 독립적인 트랜잭션 필요 시
- NOT_SUPPORTED: 트랜잭션 불필요 시 (조회만)

### 4.7 보안 설계

#### JWT 인증
- Access Token: 짧은 만료시간 (1시간)
- Refresh Token: 긴 만료시간 (7일), Redis에 저장
- 토큰 갱신 시 Refresh Token 검증

#### 권한 제어
- Method Security: @PreAuthorize, @PostAuthorize
- Custom Security Expression 구현

```java
@PreAuthorize("hasRole('ADMIN') or @postSecurity.isAuthor(#postId)")
public void updatePost(Long postId, PostUpdateRequest request) {
    // ...
}
```

#### CORS 설정
- 허용된 Origin만 접근 가능
- Credentials 허용 (쿠키 사용 시)

### 4.8 성능 모니터링

#### Actuator 엔드포인트
- /actuator/health: 헬스 체크
- /actuator/metrics: 메트릭 조회
- /actuator/prometheus: Prometheus 연동

#### JVM 모니터링
- Heap 사용률
- GC 빈도 및 소요 시간
- Thread 상태

#### 애플리케이션 메트릭
- API 응답 시간
- 에러율
- DB Connection Pool 사용률

#### 로깅 전략
- 구조화된 JSON 로깅 (Logstash 형식)
- MDC (Mapped Diagnostic Context)로 요청 추적
- 민감 정보 마스킹

## 5. 개발 단계별 계획

### Phase 1: 기반 구축
- 프로젝트 초기 설정 (Spring Boot, Gradle)
- 도메인 엔티티 구현
- Repository 계층 구현
- 기본 테스트 코드 작성

### Phase 2: 핵심 기능 구현
- 회원가입/로그인 (Spring Security + JWT)
- 게시글 CRUD
- 댓글 CRUD
- 카테고리 관리 (관리자)

### Phase 3: 고급 기능 구현
- 좋아요/싫어요 기능
- 조회수 처리
- 계층형 댓글 조회 최적화
- 검색 및 필터링

### Phase 4: 성능 최적화
- 쿼리 최적화 (N+1 해결)
- 캐싱 적용 (Redis, Ehcache)
- 조회수 비동기 처리
- 인덱스 튜닝

### Phase 5: JVM 최적화
- G1GC 튜닝
- Heap 크기 최적화
- JFR 프로파일링
- Virtual Threads 적용

### Phase 6: 테스트 및 문서화
- 단위 테스트 (80% 커버리지)
- 통합 테스트
- API 문서화 (Spring REST Docs)
- 성능 테스트 (JMeter)

## 6. 성공 지표

### 기능적 지표
- 모든 요구사항 구현 완료
- 테스트 커버리지 80% 이상
- 버그 제로

### 성능적 지표
- 게시글 목록 조회 응답시간 200ms 이하
- 게시글 상세 조회 응답시간 300ms 이하
- 동시 사용자 1,000명 처리 가능
- TPS 1,000 이상

### 기술적 지표
- Java 21 신규 기능 3개 이상 활용
- JVM 튜닝 전후 성능 개선 20% 이상
- 고급 JPA 기법 5개 이상 적용
- Spring 생태계 기술 10개 이상 활용

## 7. 리스크 관리

### 기술적 리스크
- **계층형 댓글 성능**: 프로토타입 먼저 구현하여 검증
- **동시성 이슈**: 초기부터 락 전략 수립 및 테스트
- **캐시 일관성**: 명확한 무효화 전략 수립

### 일정 리스크
- **과도한 최적화**: 최소 기능 먼저 구현 후 점진적 개선
- **기술 학습 시간**: 공식 문서 및 레퍼런스 프로젝트 참고

## 8. 참고 자료

### 공식 문서
- Spring Boot Reference Documentation
- Hibernate ORM Documentation
- Java SE 21 Documentation

### 추천 도서
- "자바 ORM 표준 JPA 프로그래밍" - 김영한
- "Optimizing Java" - Benjamin J. Evans 외
- "High-Performance Java Persistence" - Vlad Mihalcea

### 참고 프로젝트
- Spring PetClinic
- JHipster
- Real World App
